- consider co-evolve the random paths
- top level build script that builds debug/release
- benchmark the impact of debug mode code
- llm fitness function evolution
  - this could be progressively raise the bar on complexity - staged evolution
  - co-evolution
- try to simplify the eval tree by passing a class reference instead of N args
- 
- walk various classes for copy by reference, copy by pointer, copy by value == a smaller mem leak in autoc
- we can buffer the best run over a population vs re-running it -- save the final eval steps
- can not interactively flip to autoc input as it attempts to use the callback port -- soften this dependency for when it is manually run (maybe if port not set, it falls back to Mouse)
- plumb stdout/stderr nicely for a build run -- perhaps hook this into archiving system too
- figure out how to use crrcsim robots to form lead plane
- variations project - to get closer to zero-shot
  - power, drag, service response times
  - get random start/orientation working in crrcsim, consider fitness function for distance, alignment is ramped sensitivity for first couple of seconds (to allow capture from random start)
  - wind speed, direction, turbulence multipler need to vary
    * CURRENT: WindScenarios only varies turbulence/gust patterns via PRNG seed
    * Wind direction fixed at 270Â° (from scenery/config)
    * Base wind velocity fixed at 7 ft/s (from scenery/config)
    * Turbulence intensity fixed at 1.0 (relative multiplier from scenery/config)
    * TO ADD VARIATION: Modify config loading to randomize direction/velocity based on wind seed
      - See config.cpp:173-249 (T_Wind::setDefaults and read methods)
      - Wind seed controls: Dryden turbulence model gaussian noise (eta1-4 in windfield.h:131)
      - Wind seed controls: Thermal updraft positions
  - also varying speed rabbit
- GP to autoc in inav via controls
  - selector
  - activate
* clean shutdown method for terminating sims
  - now that a crrcsim batch runs long, perhaps have polling loop for keepalive as when autoc exits crrcsim will exit
- blackbox rendering improvements:
  - we will need to select a path and a blackbox log to do comparisons
  - user interface to allow selecting path, log file, etc -- similar to how the path/actual works
  - might need additional attributes on renderer playback, e.g. loss of GPS signal, etc
  - blackbox logs are 1/32 which is still a lot of data, can we do subselect, perhaps 5 hz?
  - fpv mode for playback
- also seems crrcsim is dependent on a valid DISPLAY even when in headless
- need to refactor the opcode enum to only have one -- and then to stop using numeric opcodes in the bytecode2cpp generator
- checkpoint/resume a run -- including for LLM enhancement over time, etc

- check for dangling or vestiage source files

* MAKE PATHGEN.H PORTABLE FOR EMBEDDED
  - Current: Separate embedded_pathgen_selector.h duplicates AeroStandard logic
  - Issue: Code duplication, maintenance burden, version drift risk
  - Goal: Single pathgen.h that works on both desktop and embedded
  - Method: Conditional compilation for std::vector vs fixed arrays
    * Use #ifdef EMBEDDED_BUILD to select array-based storage
    * Keep all path generation logic identical
    * Template-based or macro-based container abstraction
  - Benefits: Single source of truth, easier maintenance, guaranteed consistency
  - Defer: Wait until path system stabilizes and other generators are improved

* INVESTIGATE DOUBLE PRECISION FOR DETERMINISM
  - Current: gp_scalar = float (single precision)
  - Issue: crrcsim physics uses double internally, but converts to float at interface
  - Conversion at inputdev_autoc.cpp:474-476 loses ~9 digits of precision
  - Results in ~0.0002m position divergence from first frame
  - Divergence grows to ~0.17m by frame 100
  - Test: Change gp_types.h to use double and measure impact on:
    * Determinism (does divergence disappear?)
    * Performance (memory, CPU)
    * Flight hardware compatibility (does embedded support double?)
  - May need conditional compilation for desktop vs embedded builds

* MIGRATE AWAY FROM BOOST SERIALIZATION
  - Boost serialization is NOT portable across different Boost versions
  - Current issue: Boost 1.74 (x86) cannot read archives from Boost 1.83 (ARM64)
  - Archive version in header changes between Boost releases (v18 vs v19)
  - This breaks cross-architecture artifact sharing via S3
  - Consider alternatives:
    * cereal (header-only, modern, portable)
    * JSON (human-readable, universally portable)
    * FlatBuffers (fast, efficient, cross-platform)
    * Custom text format (simplest, most control)
  - Migration required for: EvalData, EvalResults, Path, AircraftState, ScenarioMetadata
  - Benefits: version independence, better portability, potentially smaller/faster
