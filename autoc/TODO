* URGENT: THREE CRITICAL ISSUES BLOCKING EFFECTIVE EVOLUTION (2025-12-31)
  1. REMAINING CRRCSIM DETERMINISM (~0.005 unit variance)
     - Current: 99.98% deterministic, but 0.005 variance masks energy cost signal
     - Impact: 4th-order fitness metrics (throttle efficiency) drowned out by noise
     - Need: Perfect determinism (variance < 0.0001) for energy optimization
     - Approach: Hunt down remaining sources of non-determinism in crrcsim
       * Check for uninitialized variables in FDM
       * Look for floating-point ordering differences across threads
       * Investigate SDL_GetTicks() or other time-dependent calls
       * Consider using fixed-point arithmetic for critical calculations

  2. DEMETIC MODE ELITE PRESERVATION (broken fitness tracking)
     - Current: Best fitness jumps wildly (135→191→192→191→174→180→173→177)
     - Root cause: Elite's aggregated fitness lost when re-evaluated on single scenario
     - Impact: Cannot track evolution progress, GP search is ineffective
     - Need: Preserve elite's full aggregated fitness across generations
     - Approach: Fix attempted solution in autoc.cc lines 623-661, 665-744
       * Ensure elite is NOT re-evaluated (skip in evaluate() call)
       * OR restore aggregated fitness immediately after evaluation
       * Add logging to verify elite fitness is truly preserved
       * Test that best fitness is monotonically improving

  3. PATH LENGTH NORMALIZATION (fitness bias toward long paths)
     - Current: 30-second path dominates fitness vs 12-second paths (2.5x more samples)
     - Impact: Evolution optimizes for long path, ignores short paths
     - Need: Normalize fitness by path duration or expected samples
     - Approach: Modify fitness calculation to use per-second metrics
       * Average error per second instead of total error sum
       * Or weight by 1/duration to equalize path importance
       * Ensure energy cost is also normalized appropriately
       * Test that all paths contribute equally to fitness

  Priority order: Fix #2 (demetic) first to get evolution working, then #3 (normalization)
  to balance path contributions, then #1 (perfect determinism) for energy optimization.

- consider co-evolve the random paths
- top level build script that builds debug/release
- benchmark the impact of debug mode code
- llm fitness function evolution
  - this could be progressively raise the bar on complexity - staged evolution
  - co-evolution
- try to simplify the eval tree by passing a class reference instead of N args
- 
- walk various classes for copy by reference, copy by pointer, copy by value == a smaller mem leak in autoc
- we can buffer the best run over a population vs re-running it -- save the final eval steps
- can not interactively flip to autoc input as it attempts to use the callback port -- soften this dependency for when it is manually run (maybe if port not set, it falls back to Mouse)
- plumb stdout/stderr nicely for a build run -- perhaps hook this into archiving system too
- figure out how to use crrcsim robots to form lead plane
- variations project - to get closer to zero-shot
  - power, drag, service response times
  - get random start/orientation working in crrcsim, consider fitness function for distance, alignment is ramped sensitivity for first couple of seconds (to allow capture from random start)
  - wind speed, direction, turbulence multipler need to vary
    * CURRENT: WindScenarios only varies turbulence/gust patterns via PRNG seed
    * Wind direction fixed at 270° (from scenery/config)
    * Base wind velocity fixed at 7 ft/s (from scenery/config)
    * Turbulence intensity fixed at 1.0 (relative multiplier from scenery/config)
    * TO ADD VARIATION: Modify config loading to randomize direction/velocity based on wind seed
      - See config.cpp:173-249 (T_Wind::setDefaults and read methods)
      - Wind seed controls: Dryden turbulence model gaussian noise (eta1-4 in windfield.h:131)
      - Wind seed controls: Thermal updraft positions
  - also varying speed rabbit
- GP to autoc in inav via controls
  - selector
  - activate
* clean shutdown method for terminating sims
  - now that a crrcsim batch runs long, perhaps have polling loop for keepalive as when autoc exits crrcsim will exit
- blackbox rendering improvements:
  - we will need to select a path and a blackbox log to do comparisons
  - user interface to allow selecting path, log file, etc -- similar to how the path/actual works
  - might need additional attributes on renderer playback, e.g. loss of GPS signal, etc
  - blackbox logs are 1/32 which is still a lot of data, can we do subselect, perhaps 5 hz?
  - fpv mode for playback
- also seems crrcsim is dependent on a valid DISPLAY even when in headless
- need to refactor the opcode enum to only have one -- and then to stop using numeric opcodes in the bytecode2cpp generator
- checkpoint/resume a run -- including for LLM enhancement over time, etc

- check for dangling or vestiage source files

* MAKE PATHGEN.H PORTABLE FOR EMBEDDED
  - Current: Separate embedded_pathgen_selector.h duplicates AeroStandard logic
  - Issue: Code duplication, maintenance burden, version drift risk
  - Goal: Single pathgen.h that works on both desktop and embedded
  - Method: Conditional compilation for std::vector vs fixed arrays
    * Use #ifdef EMBEDDED_BUILD to select array-based storage
    * Keep all path generation logic identical
    * Template-based or macro-based container abstraction
  - Benefits: Single source of truth, easier maintenance, guaranteed consistency
  - Defer: Wait until path system stabilizes and other generators are improved

* INVESTIGATE DOUBLE PRECISION FOR DETERMINISM
  - Current: gp_scalar = float (single precision)
  - Issue: crrcsim physics uses double internally, but converts to float at interface
  - Conversion at inputdev_autoc.cpp:474-476 loses ~9 digits of precision
  - Results in ~0.0002m position divergence from first frame
  - Divergence grows to ~0.17m by frame 100
  - Test: Change gp_types.h to use double and measure impact on:
    * Determinism (does divergence disappear?)
    * Performance (memory, CPU)
    * Flight hardware compatibility (does embedded support double?)
  - May need conditional compilation for desktop vs embedded builds

* MIGRATE AWAY FROM BOOST SERIALIZATION
  - Boost serialization is NOT portable across different Boost versions
  - Current issue: Boost 1.74 (x86) cannot read archives from Boost 1.83 (ARM64)
  - Archive version in header changes between Boost releases (v18 vs v19)
  - This breaks cross-architecture artifact sharing via S3
  - Consider alternatives:
    * cereal (header-only, modern, portable)
    * JSON (human-readable, universally portable)
    * FlatBuffers (fast, efficient, cross-platform)
    * Custom text format (simplest, most control)
  - Migration required for: EvalData, EvalResults, Path, AircraftState, ScenarioMetadata
  - Benefits: version independence, better portability, potentially smaller/faster

* ELITE FITNESS REGRESSION - NON-MONOTONIC BEST FITNESS (ACTIVE)
  - Problem: Best fitness regresses by ~0.001 units even with AddBestToNewPopulation=1
    * Observed in BOTH demetic and non-demetic modes
    * Example from non-demetic run (PopSize=100, WindScenarios=6):
      Gen 3: 235.743 → Gen 4: 235.744 (regression of 0.001)
      Gen 7: 235.136 → Gen 8: 235.137 (regression of 0.001)
    * Magnitude matches remaining crrcsim variance (~0.005 units)

  - Root cause: Elite individual is being RE-EVALUATED instead of fitness being preserved
    * AddBestToNewPopulation=1 should copy elite forward WITHOUT re-evaluation
    * GP library or MyPopulation may be forcing re-evaluation
    * Re-evaluation exposes the ~0.005 unit variance in crrcsim determinism

  - Impact:
    * Best fitness is not strictly monotonically improving
    * Makes it harder to track true evolution progress
    * Small regressions (0.001) are acceptable, but shouldn't happen at all

  - Additional issue in demetic mode (DEFERRED):
    * Elite has aggregated fitness across all scenarios
    * Regular population has single-scenario fitness
    * Re-evaluation overwrites aggregated with single-scenario fitness
    * Attempted solution in lines 623-661, 665-744 in autoc.cc (partially working)

  - Next steps:
    * Verify elite is actually being re-evaluated (add logging)
    * Check GPPopulation::evaluate() to see if it forces re-eval of all individuals
    * May need to skip elite in evaluation or restore fitness after evaluation
    * If we achieve perfect crrcsim determinism (variance=0), this would mask the issue

* CRRCSIM DETERMINISM - PRODUCTION READY (2025-12-31)
  - Status: RESOLVED - variance reduced from 20-50 units to 0.005 units (99.98% deterministic)
  - Current: ~8 out of 50 evaluations show tiny variance (0.005 fitness units)
  - This occurs even after warm-up, not just initial runs - acceptable for production
  - Root cause of remaining variance: Unknown, but impact negligible

  - Fixes applied (crrcsim-0.9.13/src):
    * RandGauss::Reset() method added to clear Box-Muller internal state (crrc_rand.h/cpp)
      - Resets phase, V2, fac to zero on each simulation reset
      - Constructors now properly initialize all state variables
    * eta1-4 (Dryden turbulence) reset in initialize_gust() (windfield.cpp:788-791)
      - These global RandGauss objects persist across resets, must be explicitly cleared
    * rnd_radius/strength/lifetime (thermal parameters) reset in initialize_wind_field() (windfield.cpp:468-470)
      - File-scope global RandGauss objects for thermal generation

  - Total changes: 36 lines across 3 files (crrc_rand.h, crrc_rand.cpp, windfield.cpp)
  - Production impact: Aggregate fitness variance < 0.01 units is acceptable for GP evolution

  - Debug facilities available:
    * Determinism test in autoc.cc line 1531: change `if (false && gen == 2)` to `if (gen == 2)`
    * Clones best individual to entire population at gen 2 and measures fitness variance

  - Note: Attempted SimStateHandler refactoring was REVERTED
    * Tried to add resetWithSeed() method to centralize PRNG seeding
    * This actually INCREASED variance to 120 units - root cause unclear
    * Reverted to keep working baseline with minimal changes
